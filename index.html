<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>數吉拉：破壞神 (Neon Kaiju)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Black+Ops+One&family=Noto+Sans+TC:wght@500;700;900&display=swap');

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed; /* Fix for mobile bounce */
            background-color: #050505;
            touch-action: none;
            font-family: 'Noto Sans TC', sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .pixel-font { font-family: 'Press Start 2P', cursive; }
        .tech-font { font-family: 'Black Ops One', cursive; letter-spacing: 1px; }

        #gameCanvas {
            background: radial-gradient(circle, #1a1a2e 0%, #000000 100%);
            display: block;
        }

        .scroller::-webkit-scrollbar { width: 6px; }
        .scroller::-webkit-scrollbar-track { background: #111; }
        .scroller::-webkit-scrollbar-thumb { background: #00ffcc; border-radius: 3px; }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-screen { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        
        .modal-overlay { background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(8px); }
        
        @keyframes slideIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .slide-in { animation: slideIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

        .neon-btn {
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }
        .neon-btn:hover {
            box-shadow: 0 0 15px currentColor;
            transform: translateY(-2px);
        }
        .neon-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(rgba(255,255,255,0.2), transparent);
            transform: rotate(45deg) translate(-100%, -100%);
            transition: transform 0.6s;
        }
        .neon-btn:hover::after {
            transform: rotate(45deg) translate(0, 0);
        }

        @keyframes comboPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); color: #fff; }
            100% { transform: scale(1); }
        }
        .combo-pop { animation: comboPop 0.2s; }

        /* Mobile specific adjustments */
        @media (max-width: 768px) {
            .mobile-text-scale { font-size: 0.8rem; }
        }
    </style>
</head>
<body class="text-white select-none">

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/95 transition-opacity duration-500 overflow-y-auto">
        <div class="my-auto p-4 flex flex-col items-center w-full max-w-md slide-in">
            <h1 class="text-4xl md:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-cyan-500 mb-2 tech-font text-center leading-normal filter drop-shadow-[0_0_10px_rgba(74,222,128,0.5)]">
                NEON KAIJU<br>
                <span class="text-xl md:text-2xl text-white pixel-font block mt-2">數吉拉：破壞神</span>
                <!-- Added Link Here -->
                <a href="https://www.facebook.com/profile.php?id=61584059466555" target="_blank" class="block mt-3 text-sm md:text-base text-yellow-400 hover:text-yellow-300 transition-colors font-bold tracking-wider border-b border-yellow-400/50 hover:border-yellow-300 pb-1">
                    @下班後的某宅羊
                </a>
            </h1>
            
            <div class="bg-gray-900/80 p-6 rounded-2xl border border-gray-700 w-full shadow-[0_0_30px_rgba(0,255,200,0.1)] backdrop-blur-md mt-4">
                <h2 class="text-lg mb-4 text-cyan-300 border-b border-gray-700 pb-2 font-bold tracking-wider">系統初始化設定</h2>
                
                <div class="mb-4">
                    <label class="block text-xs mb-2 text-gray-400 font-bold uppercase tracking-widest">運算核心 (Operators)</label>
                    <div class="flex gap-2 justify-between">
                        <button class="op-btn flex-1 py-2 bg-gray-800 hover:bg-green-900 rounded border border-gray-600 active-op text-green-400 font-bold transition-all" data-op="add">＋</button>
                        <button class="op-btn flex-1 py-2 bg-gray-800 hover:bg-green-900 rounded border border-gray-600 text-green-400 font-bold transition-all" data-op="sub">－</button>
                        <button class="op-btn flex-1 py-2 bg-gray-800 hover:bg-green-900 rounded border border-gray-600 text-green-400 font-bold transition-all" data-op="mul">×</button>
                        <button class="op-btn flex-1 py-2 bg-gray-800 hover:bg-green-900 rounded border border-gray-600 text-green-400 font-bold transition-all" data-op="div">÷</button>
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-xs mb-2 text-blue-400 font-bold uppercase tracking-widest">題目難度 (CPU Load)</label>
                    <div class="flex gap-2">
                        <button class="math-diff-btn flex-1 py-2 bg-gray-800 hover:bg-blue-900 rounded text-xs active-math-diff border border-gray-600 text-blue-300 transition-all" data-diff="easy">簡單</button>
                        <button class="math-diff-btn flex-1 py-2 bg-gray-800 hover:bg-blue-900 rounded text-xs border border-gray-600 text-blue-300 transition-all" data-diff="medium">普通</button>
                        <button class="math-diff-btn flex-1 py-2 bg-gray-800 hover:bg-blue-900 rounded text-xs border border-gray-600 text-blue-300 transition-all" data-diff="hard">困難</button>
                    </div>
                </div>

                <div class="mb-6">
                    <label class="block text-xs mb-2 text-red-400 font-bold uppercase tracking-widest">戰鬥強度 (Threat Level)</label>
                    <div class="flex gap-2">
                        <button class="combat-diff-btn flex-1 py-2 bg-gray-800 hover:bg-red-900 rounded text-xs active-combat-diff border border-gray-600 text-red-300 transition-all" data-diff="easy">休閒</button>
                        <button class="combat-diff-btn flex-1 py-2 bg-gray-800 hover:bg-red-900 rounded text-xs border border-gray-600 text-red-300 transition-all" data-diff="medium">標準</button>
                        <button class="combat-diff-btn flex-1 py-2 bg-gray-800 hover:bg-red-900 rounded text-xs border border-gray-600 text-red-300 transition-all" data-diff="hard">夢魘</button>
                    </div>
                </div>

                <button id="startGameBtn" class="w-full py-4 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-bold rounded-lg text-xl shadow-lg transform active:scale-95 transition-all neon-btn text-shadow-sm">
                    啟動破壞程序
                </button>
                <div class="mt-4 text-center text-gray-500 text-[10px] space-y-1">
                    <p>操作: 方向鍵/虛擬搖桿移動</p>
                    <p>連擊破壞可獲得高分 | 集滿能量發動雷射</p>
                </div>
            </div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud" class="hidden absolute top-0 left-0 w-full p-4 pointer-events-none z-10 flex flex-col h-full justify-between">
        <!-- Top Bar -->
        <div class="flex justify-between items-start w-full">
            <div class="flex flex-col gap-2">
                <div class="flex items-center gap-3">
                    <div class="text-yellow-400 tech-font text-2xl drop-shadow-[0_0_5px_rgba(250,204,21,0.8)]"><span id="scoreDisplay">0</span></div>
                    <div id="comboContainer" class="hidden opacity-0 transition-opacity duration-300">
                        <span class="text-orange-500 font-black italic text-xl drop-shadow-[0_0_5px_rgba(249,115,22,0.8)]">x<span id="comboDisplay">0</span> COMBO</span>
                    </div>
                </div>
                
                <div class="flex items-center gap-2">
                    <div class="px-2 py-0.5 bg-gray-800 border border-gray-600 rounded text-[10px] text-green-400 font-mono">LV.<span id="levelDisplay">1</span></div>
                    <div class="text-white text-xs font-bold tracking-wider opacity-80" id="levelNameDisplay">NEON CITY</div>
                </div>

                <!-- HP Bar -->
                <div class="w-48 h-5 bg-gray-900/80 border border-gray-600 rounded skew-x-[-12deg] relative overflow-hidden mt-1 backdrop-blur-sm">
                    <div id="healthBar" class="h-full bg-gradient-to-r from-red-600 to-red-500 w-full transition-all duration-300 shadow-[0_0_10px_rgba(239,68,68,0.5)]"></div>
                    <div class="absolute inset-0 flex items-center justify-center text-[10px] font-bold text-white/90 tracking-widest skew-x-[12deg]">INTEGRITY</div>
                </div>
                
                <!-- Energy Bar -->
                <div class="w-40 h-3 bg-gray-900/80 border border-gray-600 rounded skew-x-[-12deg] relative overflow-hidden mt-1 backdrop-blur-sm">
                    <div id="energyBar" class="h-full bg-gradient-to-r from-cyan-600 to-blue-500 w-0 transition-all duration-100 shadow-[0_0_10px_rgba(6,182,212,0.5)]"></div>
                     <div class="absolute inset-0 flex items-center justify-center text-[8px] font-bold text-white/80 tracking-widest skew-x-[12deg]">ENERGY</div>
                </div>
                
                <div id="bossContainer" class="hidden mt-1">
                    <div class="text-[10px] text-red-500 font-bold animate-pulse">WARNING: BOSS DETECTED</div>
                </div>
            </div>

            <div class="flex flex-col items-end">
                <div class="text-cyan-300 tech-font text-xl drop-shadow-[0_0_5px_rgba(34,211,238,0.8)]" id="timeDisplay">00:00</div>
                <div id="statusIcons" class="flex gap-1 mt-2 flex-wrap justify-end max-w-[150px]"></div>
            </div>
        </div>

        <!-- Touch Controls (Dash Removed) -->
    </div>

    <!-- Math Modal -->
    <div id="mathModal" class="hidden fixed inset-0 z-40 modal-overlay flex items-center justify-center p-4">
        <div class="bg-gray-900/95 border-2 border-cyan-500 rounded-2xl p-6 w-full max-w-lg shadow-[0_0_50px_rgba(6,182,212,0.3)] relative overflow-hidden slide-in backdrop-blur-xl">
            <!-- Scanning Line Effect -->
            <div class="absolute top-0 left-0 w-full h-1 bg-cyan-400/50 animate-[scan_2s_linear_infinite]"></div>
            
            <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-4">
                <h3 class="text-xl text-cyan-300 font-bold tech-font tracking-wider">FIREWALL BREACH</h3>
                <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-400">TIMEOUT:</span>
                    <span class="text-red-500 font-bold tech-font text-xl animate-pulse" id="questionTimer">10.0</span>
                </div>
            </div>
            
            <div class="bg-black/50 p-8 rounded-lg mb-6 text-center border border-gray-700 shadow-inner relative group">
                <div class="absolute inset-0 bg-cyan-500/5 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg"></div>
                <span id="mathQuestion" class="text-4xl md:text-6xl font-mono text-white font-bold filter drop-shadow-[0_0_8px_rgba(255,255,255,0.8)]"></span>
            </div>
            
            <div id="mathOptions" class="grid grid-cols-2 gap-4"></div>
        </div>
    </div>

    <!-- Level Clear Modal -->
    <div id="levelClearModal" class="hidden fixed inset-0 z-40 modal-overlay flex items-center justify-center p-4">
        <div class="bg-gray-900 border-2 border-yellow-500 rounded-xl p-8 w-full max-w-md shadow-[0_0_40px_rgba(234,179,8,0.4)] text-center slide-in relative">
            <div class="absolute -top-10 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black font-black px-6 py-2 rounded skew-x-[-12deg] shadow-lg">
                SECTOR CLEARED
            </div>
            <div class="mt-4 space-y-4 mb-8">
                <div class="flex justify-between text-gray-400 border-b border-gray-800 pb-2"><span>任務時間</span> <span id="levelTime" class="text-white font-mono"></span></div>
                <div class="flex justify-between text-gray-400 border-b border-gray-800 pb-2"><span>速度獎勵</span> <span id="timeBonus" class="text-green-400 font-mono"></span></div>
                <div class="flex justify-between text-xl mt-4"><span>累積積分</span> <span id="currentTotalScore" class="text-yellow-400 font-black text-2xl"></span></div>
            </div>
            <button id="nextLevelBtn" class="w-full py-3 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded shadow-lg neon-btn">
                前往下一區 >>
            </button>
        </div>
    </div>

    <!-- Game Over / Leaderboard Modal -->
    <div id="gameOverModal" class="hidden fixed inset-0 z-50 bg-black/95 flex flex-col items-center justify-center p-4 backdrop-blur-lg">
        <h2 id="endTitle" class="text-5xl md:text-7xl text-red-500 tech-font mb-2 text-center drop-shadow-[0_0_20px_rgba(239,68,68,0.8)]">SYSTEM FAILURE</h2>
        <div class="text-3xl text-white mb-2 font-bold">SCORE: <span id="finalScore" class="text-yellow-400">0</span></div>
        <div class="text-sm text-gray-500 mb-8 font-mono" id="finalLevelInfo">SECTOR: 1</div>
        
        <div class="w-full max-w-md bg-gray-900 rounded-xl p-6 border border-gray-800 shadow-2xl max-h-[60vh] flex flex-col">
            <div id="submitScoreSection" class="mb-6 bg-gray-800/50 p-4 rounded-lg">
                <label class="block text-xs text-gray-400 mb-2 uppercase tracking-widest">Register Score</label>
                <div class="flex gap-2">
                    <input type="text" id="playerNameInput" maxlength="10" placeholder="AGENT NAME" class="flex-1 bg-black text-white px-4 py-2 rounded border border-gray-700 focus:outline-none focus:border-cyan-500 uppercase font-mono tracking-widest text-center">
                    <button id="submitScoreBtn" class="bg-cyan-700 hover:bg-cyan-600 text-white px-6 py-2 rounded font-bold transition-colors">SAVE</button>
                </div>
            </div>
            
            <h3 class="text-sm text-green-400 mb-3 border-b border-gray-700 pb-2 font-bold uppercase tracking-widest flex items-center gap-2">
                <span class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span> Local Rankings
            </h3>
            
            <div class="flex-1 overflow-y-auto scroller bg-black/30 rounded p-2 mb-4 font-mono text-sm" id="leaderboardList">
                <div class="text-center text-gray-600 py-8">LOADING...</div>
            </div>
            
            <button onclick="location.reload()" class="w-full py-4 bg-gradient-to-r from-red-700 to-red-600 hover:from-red-600 hover:to-red-500 text-white font-bold rounded shadow-lg neon-btn tracking-widest">
                REBOOT SYSTEM
            </button>
        </div>
    </div>

    <canvas id="gameCanvas" class="block w-full h-full"></canvas>

    <script type="module">
        // Removed Firebase Imports

        // --- Audio System (Enhanced) ---
        const AudioSys = {
            ctx: null,
            init: function() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            createOsc: function(type, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                return osc;
            },
            createGain: function(vol = 0.1) {
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                return gain;
            },
            playTone: function(freq, type, duration, vol = 0.1, slideTo = null) {
                if (!this.ctx) return;
                const osc = this.createOsc(type, freq);
                const gain = this.createGain(vol);
                
                if (slideTo) {
                    osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                }
                
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playNoise: function(duration, vol = 0.1) {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                // Filter for "explosion" sound
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + duration);

                const gain = this.createGain(vol);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            sfxShoot: function() { this.playTone(800, 'sawtooth', 0.15, 0.05, 400); }, 
            sfxExplosion: function() { this.playNoise(0.5, 0.2); this.playTone(100, 'sawtooth', 0.3, 0.1, 50); },
            sfxCorrect: function() { 
                this.playTone(440, 'sine', 0.1, 0.1); 
                setTimeout(() => this.playTone(880, 'sine', 0.2, 0.1), 100); 
            },
            sfxWrong: function() { 
                this.playTone(150, 'sawtooth', 0.3, 0.1, 100); 
            },
            sfxPowerup: function() { 
                this.playTone(440, 'square', 0.1, 0.1, 880); 
                setTimeout(() => this.playTone(880, 'square', 0.2, 0.1, 1760), 100); 
            },
            sfxUltimate: function() { 
                this.playTone(100 + Math.random()*50, 'sawtooth', 0.1, 0.2);
            },
            sfxLevelClear: function() {
                [523, 659, 783, 1046, 1318].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 'triangle', 0.3, 0.1), i * 120);
                });
            },
            sfxWarning: function() {
                this.playTone(150, 'square', 0.4, 0.1, 100);
            }
        };

        // --- Game Globals ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize
        let animationId, gameTime = 0;
        const LEADERBOARD_KEY = 'neon_kaiju_local_scores';
        
        const STATE = { MENU: 0, PLAYING: 1, MATH_PAUSE: 2, GAME_OVER: 3, BOSS_FIGHT: 4, LEVEL_TRANSITION: 5 };
        const BOSS_SPAWN_THRESHOLD = 1500;
        
        // Neon Palettes
        const PALETTES = [
            { id: 1, name: "CYBER CITY", bg: '#050510', grid: '#1a1a40', buildings: ['#2dd4bf', '#0ea5e9', '#6366f1'], hazard: '#f43f5e' },
            { id: 2, name: "MAGMA CORE", bg: '#100505', grid: '#401a1a', buildings: ['#fb923c', '#ef4444', '#b91c1c'], hazard: '#fcd34d' },
            { id: 3, name: "VOID BASE",  bg: '#0a0510', grid: '#2a1a40', buildings: ['#a855f7', '#d946ef', '#8b5cf6'], hazard: '#84cc16' }
        ];

        let gameState = {
            status: STATE.MENU,
            score: 0, levelScore: 0, levelIndex: 0,
            health: 100, maxHealth: 100,
            energy: 0, maxEnergy: 100,
            operators: ['add'], 
            mathDiff: 'easy',
            combatDiff: 'easy',
            camera: { x: 0, y: 0, shake: 0 },
            keys: {}, levelStartTime: 0,
            freezeTimer: 0,
            frameCount: 0,
            combo: 0, comboTimer: 0, maxCombo: 0
        };

        let joystick = { active: false, originX: 0, originY: 0, currentX: 0, currentY: 0, dx: 0, dy: 0 };
        let player, buildings = [], particles = [], items = [], projectiles = [], boss = null, floatingTexts = [], hazards = [], backgroundStars = [];

        // --- Helper Functions ---
        function renderGlowingRect(ctx, x, y, w, h, color, blur = 10) {
            ctx.save();
            ctx.shadowBlur = blur;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
            ctx.restore();
        }

        // --- Config UI ---
        document.querySelectorAll('.op-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('bg-green-900'); btn.classList.toggle('ring-2'); btn.classList.toggle('ring-green-400'); btn.classList.toggle('active-op');
                if (document.querySelectorAll('.active-op').length === 0) {
                     btn.classList.add('bg-green-900', 'ring-2', 'ring-green-400', 'active-op');
                }
            });
        });
        
        const setupDiffBtns = (cls, activeCls, colorCls) => {
            document.querySelectorAll(cls).forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll(cls).forEach(b => {
                        b.classList.remove('bg-' + colorCls + '-900', 'ring-2', 'ring-' + colorCls + '-400', activeCls);
                    });
                    btn.classList.add('bg-' + colorCls + '-900', 'ring-2', 'ring-' + colorCls + '-400', activeCls);
                });
            });
        };
        setupDiffBtns('.math-diff-btn', 'active-math-diff', 'blue');
        setupDiffBtns('.combat-diff-btn', 'active-combat-diff', 'red');

        document.getElementById('startGameBtn').addEventListener('click', () => {
            AudioSys.init(); if (AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            gameState.operators = Array.from(document.querySelectorAll('.active-op')).map(b => b.dataset.op);
            gameState.mathDiff = document.querySelector('.active-math-diff').dataset.diff;
            gameState.combatDiff = document.querySelector('.active-combat-diff').dataset.diff;
            startGame();
        });

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            document.getElementById('levelClearModal').classList.add('hidden');
            startNextLevel();
        });

        // --- Math Logic ---
        function generateMathProblem() {
            const diff = gameState.mathDiff;
            const ops = gameState.operators;
            const op = ops[Math.floor(Math.random() * ops.length)];
            let min, max;
            if (diff === 'easy') { min = 1; max = 10; }
            else if (diff === 'medium') { min = 5; max = 50; }
            else { min = 10; max = 100; }

            let a = Math.floor(Math.random() * (max - min + 1)) + min;
            let b = Math.floor(Math.random() * (max - min + 1)) + min;
            let answer, symbol;

            switch(op) {
                case 'add': answer = a + b; symbol = '+'; break;
                case 'sub': if (a < b) [a, b] = [b, a]; answer = a - b; symbol = '-'; break;
                case 'mul': 
                    if (diff === 'hard') { a = Math.floor(a/2); b = Math.floor(b/2); } 
                    else if (diff === 'medium') { a = Math.min(a, 12); b = Math.min(b, 12); }
                    else { a = Math.min(a, 9); b = Math.min(b, 9); }
                    answer = a * b; symbol = '×'; break;
                case 'div':
                    if (diff === 'hard') { b = Math.floor(Math.random() * 12) + 2; }
                    else { b = Math.floor(Math.random() * 9) + 2; }
                    a = b * (Math.floor(Math.random() * (max/5)) + 1);
                    answer = a / b; symbol = '÷'; break;
            }
            let options = new Set([answer]);
            while (options.size < 4) {
                let wrong;
                if (op === 'mul' && diff !== 'easy') {
                    let tensOffset = (Math.floor(Math.random() * 6) - 3) * 10; 
                    if (tensOffset === 0) tensOffset = 10; 
                    wrong = answer + tensOffset;
                } else {
                    let offset = Math.floor(Math.random() * 10) - 5 || 1;
                    wrong = answer + offset;
                }
                
                if (wrong < 0 && op !== 'sub') wrong = Math.abs(wrong);
                options.add(wrong);
            }
            return { question: `${a} ${symbol} ${b} = ?`, answer: answer, options: Array.from(options).sort(() => Math.random() - 0.5) };
        }

        // --- Classes ---
        class Player {
            constructor() {
                this.baseWidth = 40; this.baseHeight = 60; // Adjusted for taller kaiju
                this.width = this.baseWidth; this.height = this.baseHeight;
                this.x = canvas.width/2; this.y = canvas.height/2;
                this.baseSpeed = 6; this.speed = 6; 
                this.vx = 0; this.vy = 0; this.direction = 1; 
                this.walkFrame = 0; 
                this.speedBoostTimer = 0;
                this.giantTimer = 0;
                this.shieldTimer = 0;
                this.invincibleTimer = 0;
                this.slowed = false; 
                this.ultimateTimer = 0;
            }

            update() {
                // Removed Dash Logic

                let moveSpeed = this.speedBoostTimer > 0 ? this.baseSpeed * 1.5 : this.baseSpeed;
                
                if (this.giantTimer > 0) {
                    this.giantTimer--;
                    this.width = this.baseWidth * 2; this.height = this.baseHeight * 2;
                } else {
                    this.width = this.baseWidth; this.height = this.baseHeight;
                }
                
                if (this.speedBoostTimer > 0) this.speedBoostTimer--;
                if (this.shieldTimer > 0) this.shieldTimer--;
                if (this.invincibleTimer > 0) this.invincibleTimer--;
                if (this.ultimateTimer > 0) {
                    this.ultimateTimer--;
                    if(this.ultimateTimer % 10 === 0) AudioSys.sfxUltimate();
                    if(this.ultimateTimer % 4 === 0) gameState.camera.shake = 5;
                }

                if (this.slowed) moveSpeed *= 0.5;
                this.slowed = false;

                let dx = 0, dy = 0;
                if (gameState.keys['ArrowUp'] || gameState.keys['w']) dy = -1;
                if (gameState.keys['ArrowDown'] || gameState.keys['s']) dy = 1;
                if (gameState.keys['ArrowLeft'] || gameState.keys['a']) { dx = -1; this.direction = -1; }
                if (gameState.keys['ArrowRight'] || gameState.keys['d']) { dx = 1; this.direction = 1; }
                
                if (joystick.active) {
                    dx = joystick.dx / 50; dy = joystick.dy / 50;
                    if (dx < -0.1) this.direction = -1;
                    if (dx > 0.1) this.direction = 1;
                }

                // Normalize diagonal speed
                if (dx !== 0 || dy !== 0) {
                    if (!joystick.active) {
                         const len = Math.sqrt(dx*dx + dy*dy);
                         dx /= len; dy /= len;
                    }
                    this.vx = dx * moveSpeed; this.vy = dy * moveSpeed;
                    this.walkFrame += 0.2;
                } else {
                    this.vx = 0; this.vy = 0;
                    this.walkFrame = 0;
                }

                this.x += this.vx; this.y += this.vy;
                this.checkBounds();
            }
            
            checkBounds() {
                 this.x = Math.max(0, Math.min(this.x, 2000 - this.width));
                 this.y = Math.max(0, Math.min(this.y, 2000 - this.height));
            }

            draw(ctx, camX, camY) {
                const drawX = this.x - camX, drawY = this.y - camY;
                ctx.save();
                ctx.translate(drawX + this.width/2, drawY + this.height/2);
                
                // Ultimate Beam
                if (this.ultimateTimer > 0) {
                    ctx.save();
                    ctx.scale(this.direction, 1);
                    const beamWidth = 80 + Math.sin(gameState.frameCount * 0.8) * 30;
                    ctx.shadowBlur = 30; ctx.shadowColor = '#06b6d4';
                    // Core
                    ctx.fillStyle = '#ccfbf1';
                    ctx.fillRect(20, -beamWidth/4, 2000, beamWidth/2);
                    // Glow
                    ctx.fillStyle = 'rgba(6, 182, 212, 0.4)';
                    ctx.fillRect(20, -beamWidth/2, 2000, beamWidth);
                    
                    // Sparks
                    for(let i=0; i<3; i++) {
                         ctx.fillStyle = 'white';
                         ctx.fillRect(Math.random()*2000, (Math.random()-0.5)*beamWidth, 10, 2);
                    }
                    ctx.restore();
                }

                // Shield
                if (this.shieldTimer > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(59, 130, 246, ${0.5 + Math.sin(Date.now()/100)*0.3})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10; ctx.shadowColor = '#3b82f6';
                    ctx.arc(0, 0, Math.max(this.width, this.height)*0.8, 0, Math.PI*2);
                    ctx.stroke();
                }

                // Invincible Flicker
                if (this.invincibleTimer > 0 && Math.floor(Date.now()/50)%2===0) { ctx.restore(); return; }

                ctx.scale(this.direction, 1);
                const s = this.width / this.baseWidth; 
                ctx.scale(s, s);

                // --- NEW KAIJU ART ---
                const mainColor = this.giantTimer > 0 ? '#d946ef' : (this.speedBoostTimer > 0 ? '#38bdf8' : '#4ade80');
                const darkColor = this.giantTimer > 0 ? '#86198f' : (this.speedBoostTimer > 0 ? '#0284c7' : '#166534');
                const glowColor = this.ultimateTimer > 0 ? '#06b6d4' : (this.energy >= 100 ? '#f59e0b' : '#10b981');
                
                ctx.shadowBlur = 15; ctx.shadowColor = mainColor;

                // Tail (Thicker, longer, spiked)
                const tailWag = Math.sin(this.walkFrame) * 8;
                ctx.fillStyle = darkColor;
                ctx.beginPath(); 
                ctx.moveTo(-10, 20); 
                ctx.quadraticCurveTo(-30, 30 + tailWag, -60, 10 + tailWag); // Tip
                ctx.quadraticCurveTo(-30, 15 + tailWag, -10, 10);
                ctx.fill();

                // Dorsal Plates (Spikes)
                ctx.fillStyle = glowColor;
                if(this.ultimateTimer > 0) ctx.shadowColor = '#06b6d4';
                for(let i=0; i<4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-15 - (i*2), -20 + (i*14));
                    ctx.lineTo(-35 - (i*3), -10 + (i*14)); // Pointy tip
                    ctx.lineTo(-15 - (i*2), 0 + (i*14));
                    ctx.fill();
                }

                // Body (Main Shape)
                ctx.fillStyle = mainColor;
                ctx.beginPath();
                ctx.moveTo(10, -30); // Head top
                ctx.lineTo(20, -20); // Snout
                ctx.lineTo(15, -10); // Jaw
                ctx.lineTo(18, 5);   // Chest out
                ctx.lineTo(10, 30);  // Hips
                ctx.lineTo(-15, 25); // Back hip
                ctx.lineTo(-20, -20);// Back neck
                ctx.closePath();
                ctx.fill();

                // Chest Core (Glowing)
                ctx.fillStyle = glowColor;
                ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(0, -5, 5 + (Math.sin(gameState.frameCount*0.2)*2), 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;

                // Eye (Glowing, Angry)
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(8, -26);
                ctx.lineTo(15, -23);
                ctx.lineTo(10, -20);
                ctx.fill();

                // Legs (Thick, Stomping)
                ctx.fillStyle = darkColor; 
                const lOff = Math.sin(this.walkFrame) * 8;
                // Back Leg
                ctx.fillRect(-15, 20, 12, 18 + lOff); 
                // Front Leg
                ctx.fillRect(5, 20, 12, 18 - lOff); 

                // Arms (Claws)
                const aOff = Math.cos(this.walkFrame) * 5;
                ctx.fillStyle = darkColor;
                ctx.beginPath();
                ctx.moveTo(5, -10 + aOff);
                ctx.lineTo(25, -5 + aOff);
                ctx.lineTo(15, 5 + aOff);
                ctx.fill();

                ctx.restore();
            }
        }

        class Boss {
            constructor(type, baseHp) {
                this.x = player.x + 400; this.y = player.y;
                this.width = 120; this.height = 120;
                let hpMult = 1;
                if (gameState.combatDiff === 'medium') hpMult = 1.3;
                if (gameState.combatDiff === 'hard') hpMult = 1.8;
                if (gameState.levelIndex === 2) hpMult *= 1.5;

                this.maxHp = baseHp * hpMult;
                this.hp = this.maxHp;
                this.type = type; 
                this.moveTimer = 0; this.targetY = this.y;
                this.state = 'hover'; this.chargeTimer = 0;
                this.bob = 0;

                this.attackRateMult = gameState.combatDiff === 'hard' ? 0.5 : (gameState.combatDiff === 'medium' ? 0.8 : 1.2);
                this.speedMult = gameState.combatDiff === 'hard' ? 1.5 : (gameState.combatDiff === 'medium' ? 1.2 : 0.8);
            }
            update() {
                if (gameState.freezeTimer > 0) return;
                this.bob += 0.05;

                if (this.state === 'hover') {
                    this.y += (this.targetY - this.y) * 0.05 * this.speedMult;
                    this.moveTimer++;
                    // Hover behavior
                    if (this.x - player.x < 300) this.x += 3 * this.speedMult;
                    if (this.x - player.x > 600) this.x -= 3 * this.speedMult;
                    
                    // Always try to face Y
                    this.targetY = player.y + Math.sin(this.bob)*100;

                    const moveThreshold = 100 * this.attackRateMult;
                    if (this.moveTimer > moveThreshold) {
                        const chargeChance = gameState.combatDiff === 'hard' ? 0.4 : 0.2;
                        if (Math.random() < chargeChance) {
                            this.state = 'charge_warn'; this.chargeTimer = 60; AudioSys.sfxWarning();
                        } else {
                            this.shoot(); this.moveTimer = 0;
                        }
                    }
                } 
                else if (this.state === 'charge_warn') {
                    this.chargeTimer--;
                    this.x += (Math.random()-0.5)*10; this.y += (Math.random()-0.5)*10; // Shake
                    if (this.chargeTimer <= 0) {
                        this.state = 'charging'; this.chargeTimer = 50;
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        this.vx = Math.cos(angle) * 18 * this.speedMult; this.vy = Math.sin(angle) * 18 * this.speedMult;
                    }
                }
                else if (this.state === 'charging') {
                    this.x += this.vx; this.y += this.vy; this.chargeTimer--;
                    if (this.chargeTimer <= 0) { this.state = 'hover'; this.moveTimer = 0; }
                }
            }

            shoot() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const speed = 7 * this.speedMult;
                const pColor = this.type === 'mech' ? '#ef4444' : (this.type === 'dragon' ? '#f97316' : '#d946ef');
                
                if (this.type === 'dragon') {
                     // Triple Shot
                     for(let i=-1; i<=1; i++) {
                        projectiles.push({ x: this.x, y: this.y, vx: Math.cos(angle + i*0.3)*speed, vy: Math.sin(angle + i*0.3)*speed, type: 'enemy', color: pColor, size: 8 });
                    }
                } else {
                    projectiles.push({ x: this.x, y: this.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, type: 'enemy', color: pColor, size: 10 });
                }
                AudioSys.sfxShoot();
            }

            draw(ctx, cx, cy) {
                const dx = this.x - cx, dy = this.y - cy + Math.sin(this.bob)*10;
                
                if (this.state === 'charge_warn') {
                     // Warning line
                     ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random()})`;
                     ctx.lineWidth = 2;
                     ctx.beginPath(); ctx.moveTo(dx, dy); ctx.lineTo(player.x-cx, player.y-cy); ctx.stroke();
                     
                     ctx.strokeStyle = 'red'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(dx, dy, 70, 0, Math.PI*2); ctx.stroke();
                }
                
                if (gameState.freezeTimer > 0) { ctx.shadowBlur = 20; ctx.shadowColor = 'cyan'; }
                else { ctx.shadowBlur = 20; ctx.shadowColor = 'red'; }

                // Boss Art
                ctx.save();
                ctx.translate(dx, dy);
                if (this.x > player.x) ctx.scale(-1, 1); // Face player

                if (this.type === 'mech') {
                    // Mech Body
                    ctx.fillStyle = '#374151'; ctx.fillRect(-40, -50, 80, 100);
                    ctx.fillStyle = '#ef4444'; ctx.fillRect(-20, -20, 40, 40); // Core
                    // Arms
                    ctx.fillStyle = '#1f2937'; ctx.fillRect(-60, -40, 20, 60); ctx.fillRect(40, -40, 20, 60);
                } else if (this.type === 'dragon') {
                    ctx.fillStyle = '#7f1d1d'; 
                    // Body
                    ctx.beginPath(); ctx.ellipse(0, 0, 50, 30, 0, 0, Math.PI*2); ctx.fill();
                    // Head
                    ctx.beginPath(); ctx.moveTo(30, -10); ctx.lineTo(70, -20); ctx.lineTo(60, 10); ctx.fill();
                    // Wings
                    ctx.fillStyle = '#dc2626';
                    ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-40, -80); ctx.lineTo(20, -80); ctx.fill();
                } else if (this.type === 'ufo') {
                    ctx.fillStyle = '#581c87'; ctx.beginPath(); ctx.ellipse(0, 0, 60, 20, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(0, -10, 30, Math.PI, 0); ctx.fill();
                    // Lights
                    ctx.fillStyle = Math.random() > 0.5 ? '#ffff00' : '#ff0000';
                    ctx.beginPath(); ctx.arc(-40, 0, 5, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(40, 0, 5, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(0, 5, 5, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
                ctx.shadowBlur = 0;

                // HP Bar
                const hpPercent = Math.max(0, this.hp / this.maxHp);
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(dx - 50, dy - 80, 100, 8);
                ctx.fillStyle = '#ef4444'; ctx.fillRect(dx - 50, dy - 80, 100 * hpPercent, 8);
            }
        }

        // --- Core Functions ---
        function initGame() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', (e) => gameState.keys[e.key] = true);
            window.addEventListener('keyup', (e) => gameState.keys[e.key] = false);
            setupTouchControls();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function setupTouchControls() {
            canvas.addEventListener('touchstart', e => {
                if(e.target.closest('button')) return; 
                e.preventDefault(); const t = e.changedTouches[0];
                joystick.active = true; joystick.originX = t.clientX; joystick.originY = t.clientY;
                joystick.currentX = t.clientX; joystick.currentY = t.clientY; joystick.dx = 0; joystick.dy = 0;
            }, {passive: false});
            canvas.addEventListener('touchmove', e => {
                e.preventDefault(); if (!joystick.active) return;
                const t = e.changedTouches[0]; joystick.currentX = t.clientX; joystick.currentY = t.clientY;
                let dx = joystick.currentX - joystick.originX, dy = joystick.currentY - joystick.originY;
                const dist = Math.sqrt(dx*dx + dy*dy), maxR = 50;
                if (dist > maxR) { const r = maxR/dist; dx *= r; dy *= r; joystick.currentX = joystick.originX + dx; joystick.currentY = joystick.originY + dy; }
                joystick.dx = dx; joystick.dy = dy;
            }, {passive: false});
            const end = e => { e.preventDefault(); joystick.active = false; joystick.dx = 0; joystick.dy = 0; };
            canvas.addEventListener('touchend', end); canvas.addEventListener('touchcancel', end);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            gameState.score = 0; gameState.levelIndex = 0; gameState.health = 100; gameState.energy = 0; gameState.frameCount = 0;
            gameState.combo = 0;
            startNextLevel(true);
            if (!animationId) animate();
            
            // Clock
            setInterval(() => {
                if(gameState.status === STATE.PLAYING || gameState.status === STATE.BOSS_FIGHT) {
                    gameTime++;
                    const m = Math.floor(gameTime/60).toString().padStart(2, '0'), s = (gameTime%60).toString().padStart(2, '0');
                    document.getElementById('timeDisplay').innerText = `${m}:${s}`;
                }
            }, 1000);
        }

        function startNextLevel(isReset = false) {
            if (!isReset) gameState.levelIndex++;
            if (gameState.levelIndex >= PALETTES.length) { endGame(true); return; }

            const lvl = PALETTES[gameState.levelIndex];
            const bossTypes = ['mech', 'dragon', 'ufo'];
            const bossHPs = [300, 500, 800];
            
            // Set styles based on level palette
            document.getElementById('levelDisplay').innerText = lvl.id;
            document.getElementById('levelNameDisplay').innerText = lvl.name;
            
            gameState.status = STATE.PLAYING;
            gameState.levelStartTime = gameTime;
            gameState.levelScore = 0;
            gameState.freezeTimer = 0;
            gameState.bossData = { type: bossTypes[gameState.levelIndex], hp: bossHPs[gameState.levelIndex] };
            
            player = new Player();
            player.x = canvas.width/2; player.y = canvas.height/2;
            buildings = []; items = []; particles = []; projectiles = []; boss = null; hazards = []; floatingTexts = [];
            
            generateCity(0, 0, 2000, 2000, lvl.buildings);
            generateHazards(lvl.hazard);
            initBackgroundStars();

            updateHUD();
            document.getElementById('bossContainer').classList.add('hidden');
            spawnFloatingText(`SECTOR ${lvl.id}: START`, player.x, player.y - 100, '#fff', 30);
        }

        class Building {
            constructor(x, y, w, h, colors) {
                this.x = x; this.y = y; this.width = w; this.height = h;
                this.health = Math.floor(w * h / 100); this.maxHealth = this.health;
                this.baseColor = colors[Math.floor(Math.random()*colors.length)];
                this.windows = [];
                for(let i=5; i<w-10; i+=15) for(let j=5; j<h-10; j+=20) if(Math.random() > 0.4) this.windows.push({x: i, y: j, on: Math.random()>0.5});
            }
            draw(ctx, cx, cy) {
                if(this.x-cx+this.width<0 || this.x-cx>canvas.width || this.y-cy+this.height<0 || this.y-cy>canvas.height) return;
                
                // Neon glow outline
                ctx.shadowBlur = 10; ctx.shadowColor = this.baseColor;
                ctx.fillStyle = 'rgba(10,10,20,0.9)'; 
                ctx.fillRect(this.x-cx, this.y-cy, this.width, this.height);
                
                ctx.strokeStyle = this.baseColor; ctx.lineWidth = 2; 
                ctx.strokeRect(this.x-cx, this.y-cy, this.width, this.height);
                
                ctx.shadowBlur = 0; // Windows don't need heavy blur
                this.windows.forEach(w => {
                    if (w.on) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(this.x-cx + w.x, this.y-cy + w.y, 6, 10);
                    }
                });
                
                // Damage cracks
                if (this.health < this.maxHealth) { 
                    ctx.strokeStyle = 'black'; 
                    ctx.beginPath(); 
                    ctx.moveTo(this.x-cx, this.y-cy); 
                    ctx.lineTo(this.x-cx + this.width/2, this.y-cy + this.height/2); 
                    ctx.stroke(); 
                }
            }
        }

        function generateCity(sx, sy, w, h, colors) {
            for(let x = sx + 100; x < sx + w; x += 160) {
                for(let y = sy + 100; y < sy + h; y += 160) {
                    if (Math.random() > 0.25) buildings.push(new Building(x, y, 70+Math.random()*50, 80+Math.random()*120, colors));
                }
            }
        }

        function generateHazards(color) {
            const count = 12;
            for(let i=0; i<count; i++) {
                const x = Math.random() * 1800 + 100;
                const y = Math.random() * 1800 + 100;
                if (Math.abs(x - 1000) < 200 && Math.abs(y - 1000) < 200) continue; 
                hazards.push({ x, y, width: 80, height: 80, color: color, tick: Math.random()*100 });
            }
        }

        function initBackgroundStars() {
            backgroundStars = [];
            for(let i=0; i<100; i++) backgroundStars.push({x: Math.random()*2000, y: Math.random()*2000, size: Math.random()*2, blinkSpeed: Math.random()*0.1});
        }

        function spawnFloatingText(text, x, y, color, fontSize = 20) { 
            floatingTexts.push({ text, x, y, color, size: fontSize, life: 60, vy: -1.5 }); 
        }
        
        function spawnParticles(x, y, color, count = 10, speed = 5) {
            for(let i=0; i<count; i++) {
                particles.push(new Particle(x, y, color, (Math.random()-0.5)*speed, (Math.random()-0.5)*speed, Math.random()*0.5 + 0.5));
            }
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').innerText = Math.floor(gameState.score);
            document.getElementById('comboDisplay').innerText = gameState.combo;
            
            const comboContainer = document.getElementById('comboContainer');
            if(gameState.combo > 1) {
                comboContainer.classList.remove('hidden', 'opacity-0');
                comboContainer.classList.add('combo-pop');
                setTimeout(() => comboContainer.classList.remove('combo-pop'), 200);
            } else {
                comboContainer.classList.add('opacity-0');
            }

            document.getElementById('healthBar').style.width = `${Math.max(0, gameState.health)}%`;
            document.getElementById('energyBar').style.width = `${Math.min(100, gameState.energy)}%`;
            
            const icons = [];
            if (player && player.giantTimer > 0) icons.push(`<span class="text-purple-400 font-bold border border-purple-400 px-1 rounded bg-purple-900/50">MEGA</span>`);
            if (player && player.shieldTimer > 0) icons.push(`<span class="text-blue-400 font-bold border border-blue-400 px-1 rounded bg-blue-900/50">SHIELD</span>`);
            if (gameState.freezeTimer > 0) icons.push(`<span class="text-cyan-400 font-bold border border-cyan-400 px-1 rounded bg-cyan-900/50">FREEZE</span>`);
            document.getElementById('statusIcons').innerHTML = icons.join(' ');
        }

        function showMathProblem() {
            gameState.status = STATE.MATH_PAUSE;
            const p = generateMathProblem();
            const modal = document.getElementById('mathModal');
            document.getElementById('mathQuestion').innerText = p.question;
            const optsEl = document.getElementById('mathOptions'); optsEl.innerHTML = '';
            modal.classList.remove('hidden');
            
            let t = 10.0; const tEl = document.getElementById('questionTimer'); tEl.innerText = t.toFixed(1);
            const timer = setInterval(() => {
                t -= 0.1; tEl.innerText = t.toFixed(1);
                if(t <= 0) { clearInterval(timer); resolveMath(false); }
            }, 100);
            
            p.options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = "bg-gray-800 hover:bg-cyan-700 text-cyan-300 font-mono text-xl font-bold py-4 rounded-xl border border-cyan-900 transition-all neon-btn";
                btn.innerText = Number.isInteger(opt) ? opt : opt.toFixed(2);
                btn.onclick = () => { clearInterval(timer); resolveMath(Math.abs(opt - p.answer) < 0.01); };
                optsEl.appendChild(btn);
            });
        }
        
        function handleLevelClear() {
            gameState.status = STATE.LEVEL_TRANSITION;
            AudioSys.sfxLevelClear();
            const levelTime = gameTime - gameState.levelStartTime;
            const targetTime = 180; 
            const bonus = Math.max(0, (targetTime - levelTime) * 100);
            gameState.score += 2000 + bonus;
            updateHUD();
            document.getElementById('levelTime').innerText = `${levelTime}s`;
            document.getElementById('timeBonus').innerText = `+${bonus}`;
            document.getElementById('currentTotalScore').innerText = Math.floor(gameState.score);
            document.getElementById('levelClearModal').classList.remove('hidden');
        }

        function resolveMath(correct) {
            document.getElementById('mathModal').classList.add('hidden');
            if (correct) {
                AudioSys.sfxCorrect();
                gameState.score += 500 * (1 + (gameState.combo * 0.1));
                gameState.health = Math.min(100, gameState.health + 10);
                
                gameState.energy += 30;
                if (gameState.energy >= 100) {
                    gameState.energy = 0; 
                    spawnFloatingText("ULTIMATE READY!", player.x, player.y - 70, '#f59e0b', 24);
                    player.ultimateTimer = 300; 
                    AudioSys.sfxUltimate();
                } else {
                    spawnFloatingText("ENERGY CHARGED", player.x, player.y - 50, '#60a5fa');
                    if (boss) {
                        const originX = player.x + player.width/2;
                        const originY = player.y + player.height/2;
                        const angle = Math.atan2(boss.y - originY, boss.x - originX);
                        projectiles.push({ x: originX, y: originY, vx: Math.cos(angle)*15, vy: Math.sin(angle)*15, type: 'player_laser', width: 40 });
                        AudioSys.sfxShoot();
                    } else {
                         buildings.forEach(b => {
                            const dx = (b.x + b.width/2) - player.x; const dy = (b.y + b.height/2) - player.y;
                            if(Math.sqrt(dx*dx + dy*dy) < 400) { b.health = 0; }
                        });
                        gameState.camera.shake = 20;
                        AudioSys.sfxExplosion();
                    }
                }
            } else {
                AudioSys.sfxWrong(); gameState.health -= 15; spawnFloatingText("SYSTEM ERROR -15HP", player.x, player.y - 50, '#ef4444');
                gameState.combo = 0;
            }
            updateHUD(); gameState.status = boss ? STATE.BOSS_FIGHT : STATE.PLAYING;
        }

        function triggerBoss() {
            gameState.status = STATE.BOSS_FIGHT;
            boss = new Boss(gameState.bossData.type, gameState.bossData.hp);
            spawnFloatingText("WARNING: BOSS", player.x, player.y - 100, '#ef4444', 30);
            document.getElementById('bossContainer').classList.remove('hidden');
            AudioSys.sfxWarning();
        }

        function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) { return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1; }

        class Item {
            constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.size = 15; this.bobOffset = Math.random() * Math.PI; }
            update() { this.bobOffset += 0.1; }
            draw(ctx, cx, cy) {
                const dx = this.x - cx, dy = this.y - cy + Math.sin(this.bobOffset) * 5;
                ctx.shadowBlur = 10;
                if (this.type === 'math') {
                    ctx.shadowColor = '#3b82f6'; ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(dx, dy, this.size, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.font = 'bold 16px monospace'; ctx.fillText('?', dx-5, dy+5);
                } else if (this.type === 'heal') {
                    ctx.shadowColor = '#22c55e'; ctx.fillStyle = '#22c55e'; ctx.fillRect(dx-8, dy-8, 16, 16);
                    ctx.fillStyle = 'white'; ctx.fillText('+', dx-4, dy+4);
                } else if (this.type === 'speed') {
                    ctx.shadowColor = '#eab308'; ctx.fillStyle = '#eab308'; ctx.beginPath(); ctx.moveTo(dx, dy-10); ctx.lineTo(dx-8, dy+5); ctx.lineTo(dx+8, dy+5); ctx.fill();
                } else if (this.type === 'mega') {
                    ctx.shadowColor = '#a855f7'; ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(dx, dy, this.size + Math.sin(this.bobOffset)*2, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'shield') {
                    ctx.shadowColor = '#3b82f6'; ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(dx, dy, this.size, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle='#fff'; ctx.fillText('S', dx-4, dy+4);
                } else if (this.type === 'freeze') {
                    ctx.shadowColor = '#06b6d4'; ctx.fillStyle = '#06b6d4'; ctx.fillRect(dx-6, dy-6, 12, 12);
                }
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, color, vx, vy, life) {
                this.x = x; this.y = y; this.color = color; this.vx = vx; this.vy = vy; 
                this.life = life; this.maxLife = life;
                this.gravity = 0.5; // Gravity
                this.size = Math.random()*4+2;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += this.gravity; // Apply Gravity
                
                // Bounce off ground (fake ground is unnecessary here as top down, but let's make them 'fall' and stop)
                if (this.life < 0.2) this.size *= 0.9;
                
                this.life -= 0.02;
            }
            draw(ctx, cx, cy) {
                if (this.x - cx < 0 || this.x - cx > canvas.width || this.y - cy < 0 || this.y - cy > canvas.height) return;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color; 
                ctx.fillRect(this.x-cx, this.y-cy, this.size, this.size); 
                ctx.globalAlpha = 1.0;
            }
        }

        function checkCollisions() {
            // Hazard Damage
            if (player.shieldTimer <= 0 && player.invincibleTimer <= 0) {
                hazards.forEach(h => {
                    if (rectIntersect(player.x, player.y, player.width, player.height, h.x, h.y, h.width, h.height)) {
                        if (gameState.frameCount % 30 === 0) { 
                            gameState.health -= 5; updateHUD(); spawnFloatingText("-5", player.x, player.y, 'red');
                            player.invincibleTimer = 20;
                            AudioSys.sfxWrong();
                        }
                    }
                });
            }

            // Building Collision
            for (let i = buildings.length - 1; i >= 0; i--) {
                let b = buildings[i];
                if(rectIntersect(player.x, player.y, player.width, player.height, b.x, b.y, b.width, b.height)) {
                    if (player.giantTimer > 0) {
                        b.health = 0;
                    } else {
                        const dmg = 4 + (player.speedBoostTimer > 0 ? 5 : 0);
                        b.health -= dmg; player.x -= player.vx * 1.5; player.y -= player.vy * 1.5;
                        gameState.camera.shake = 5;
                        AudioSys.sfxExplosion();
                    }
                }
            }

            // Items
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                const pickupRadius = (player.width/2) + item.size + (player.giantTimer > 0 ? 20 : 0);
                if (Math.sqrt((player.x+player.width/2-item.x)**2 + (player.y+player.height/2-item.y)**2) < pickupRadius) {
                    items.splice(i, 1); AudioSys.sfxPowerup();
                    if (item.type === 'math') showMathProblem();
                    else if (item.type === 'heal') { gameState.health = Math.min(100, gameState.health + 20); spawnFloatingText("REPAIR +20%", player.x, player.y, '#22c55e'); }
                    else if (item.type === 'speed') { player.speedBoostTimer = 300; spawnFloatingText("OVERDRIVE!", player.x, player.y, '#fbbf24'); }
                    else if (item.type === 'mega') { player.giantTimer = 600; AudioSys.sfxPowerup(); spawnFloatingText("GIGA MODE!", player.x, player.y, '#a855f7'); }
                    else if (item.type === 'shield') { player.shieldTimer = 600; AudioSys.sfxPowerup(); spawnFloatingText("SHIELD UP!", player.x, player.y, '#3b82f6'); }
                    else if (item.type === 'freeze') { gameState.freezeTimer = 300; AudioSys.sfxPowerup(); spawnFloatingText("SYSTEM FREEZE!", player.x, player.y, '#06b6d4'); }
                    updateHUD();
                }
            }
            
            // Ultimate Beam vs Buildings
            if (player.ultimateTimer > 0) {
                const beamW = 100;
                const pCx = player.x + player.width/2;
                const pCy = player.y + player.height/2;

                // Check Buildings in Beam
                for (let i = buildings.length - 1; i >= 0; i--) {
                    let b = buildings[i];
                    let hit = false;
                    // Check logic based on direction
                    if (player.direction === 1) { // Right
                        if (b.x > pCx && b.x < pCx + 2000 && Math.abs(b.y + b.height/2 - pCy) < beamW) hit = true;
                    } else { // Left
                        if (b.x < pCx && b.x > pCx - 2000 && Math.abs(b.y + b.height/2 - pCy) < beamW) hit = true;
                    }
                    
                    if (hit) {
                        b.health = 0; // Instantly destroy
                    }
                }
            }
            
            if (boss) {
                // Ultimate Collision
                if (player.ultimateTimer > 0) {
                    const beamW = 100;
                    const pCx = player.x + player.width/2;
                    const pCy = player.y + player.height/2;
                    
                    let hit = false;
                    if (player.direction === 1) { 
                        if (boss.x > pCx && boss.x < pCx + 2000 && Math.abs(boss.y + boss.height/2 - pCy) < beamW) hit = true;
                    } else { 
                        if (boss.x < pCx && boss.x > pCx - 2000 && Math.abs(boss.y + boss.height/2 - pCy) < beamW) hit = true;
                    }

                    if (hit) {
                        boss.hp -= 3; 
                        if(gameState.frameCount % 10 === 0) { spawnFloatingText("CRITICAL", boss.x, boss.y, '#fff'); spawnParticles(boss.x, boss.y, 'white', 5); }
                        if (boss.hp <= 0) { boss = null; handleLevelClear(); }
                    }
                }

                if (boss && player.invincibleTimer <= 0 && player.shieldTimer <= 0) {
                    if (rectIntersect(player.x, player.y, player.width, player.height, boss.x-50, boss.y-60, 100, 120)) {
                        const dmg = boss.state === 'charging' ? 20 : 5;
                        gameState.health -= dmg;
                        player.x -= (boss.x - player.x) * 0.1; // Knockback
                        player.invincibleTimer = 40;
                        gameState.camera.shake = 15;
                        spawnFloatingText(`-${dmg} HP`, player.x, player.y, 'red');
                        AudioSys.sfxExplosion();
                        updateHUD(); 
                    }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                let hit = false;

                if (p.type === 'enemy') {
                    if (player.invincibleTimer <= 0 && player.shieldTimer <= 0 &&
                        rectIntersect(p.x, p.y, p.size || 10, p.size || 10, player.x, player.y, player.width, player.height)) {
                        gameState.health -= 8; 
                        player.invincibleTimer = 30; hit = true;
                        gameState.camera.shake = 5;
                        AudioSys.sfxExplosion();
                        spawnFloatingText("-8 HP", player.x, player.y, 'red');
                        updateHUD(); 
                    }
                } else if (p.type === 'player_laser' && boss) {
                    if (rectIntersect(p.x, p.y, 40, 10, boss.x - 50, boss.y - 60, 100, 120)) {
                        boss.hp -= 50; 
                        spawnFloatingText("-50", boss.x, boss.y, 'cyan'); 
                        AudioSys.sfxExplosion();
                        if (boss.hp <= 0) { boss = null; handleLevelClear(); }
                        hit = true;
                    }
                }
                if (hit) projectiles.splice(i, 1);
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            if (gameState.status === STATE.MATH_PAUSE || gameState.status === STATE.GAME_OVER || gameState.status === STATE.LEVEL_TRANSITION) return;
            gameState.frameCount++;
            
            // Screen Shake Logic
            let shakeX = 0, shakeY = 0;
            if (gameState.camera.shake > 0) {
                shakeX = (Math.random() - 0.5) * gameState.camera.shake;
                shakeY = (Math.random() - 0.5) * gameState.camera.shake;
                gameState.camera.shake *= 0.9;
                if(gameState.camera.shake < 0.5) gameState.camera.shake = 0;
            }

            // Combo Decay
            if (gameState.combo > 0) {
                gameState.comboTimer--;
                if (gameState.comboTimer <= 0) {
                    gameState.combo = 0;
                    updateHUD();
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Camera follow
            let targetCamX = player.x - canvas.width / 2;
            let targetCamY = player.y - canvas.height / 2;
            
            // Smooth Camera
            gameState.camera.x += (targetCamX - gameState.camera.x) * 0.1;
            gameState.camera.y += (targetCamY - gameState.camera.y) * 0.1;
            
            // Clamp
            gameState.camera.x = Math.max(0, Math.min(gameState.camera.x, 2000 - canvas.width));
            gameState.camera.y = Math.max(0, Math.min(gameState.camera.y, 2000 - canvas.height));

            const cx = gameState.camera.x + shakeX, cy = gameState.camera.y + shakeY;

            // Background
            const lvl = PALETTES[gameState.levelIndex];
            ctx.fillStyle = lvl.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid Effect (Perspective Illusion)
            ctx.strokeStyle = lvl.grid; ctx.lineWidth = 1;
            const ox = -cx % 100, oy = -cy % 100;
            ctx.beginPath(); 
            for(let x=ox; x<canvas.width; x+=100) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); } 
            for(let y=oy; y<canvas.height; y+=100) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); } 
            ctx.stroke();

            // Stars
            ctx.fillStyle = '#fff';
            backgroundStars.forEach(s => {
                const sx = (s.x - cx*0.5 + 2000) % 2000; // Parallax
                const sy = (s.y - cy*0.5 + 2000) % 2000;
                if(sx > 0 && sx < canvas.width && sy > 0 && sy < canvas.height) {
                     ctx.globalAlpha = 0.5 + Math.sin(gameTime * s.blinkSpeed)*0.5;
                     ctx.fillRect(sx, sy, s.size, s.size);
                }
            });
            ctx.globalAlpha = 1.0;

            // Updates
            player.update(); 
            hazards.forEach(h => {
                h.tick++;
                if (h.x - cx + h.width > 0 && h.x - cx < canvas.width && h.y - cy + h.height > 0 && h.y - cy < canvas.height) {
                     ctx.shadowBlur = 15; ctx.shadowColor = h.color;
                     ctx.strokeStyle = h.color; ctx.lineWidth = 2;
                     const pulse = Math.sin(h.tick * 0.1) * 5;
                     ctx.strokeRect(h.x - cx - pulse, h.y - cy - pulse, h.width + pulse*2, h.height + pulse*2);
                     ctx.fillStyle = h.color; ctx.globalAlpha = 0.3;
                     ctx.fillRect(h.x - cx, h.y - cy, h.width, h.height);
                     ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
                }
            });
            
            checkCollisions(); 
            if (boss) boss.update();
            if (gameState.freezeTimer > 0) gameState.freezeTimer--;

            for (let i = projectiles.length - 1; i >= 0; i--) { 
                if (gameState.freezeTimer <= 0 || projectiles[i].type.includes('laser')) {
                    let p = projectiles[i]; p.x += p.vx; p.y += p.vy; 
                    if(p.x < 0 || p.x > 3000 || p.y < 0 || p.y > 3000) projectiles.splice(i, 1); 
                }
            }

            for (let i = buildings.length - 1; i >= 0; i--) {
                let b = buildings[i];
                if (b.health <= 0) {
                    // Combo Logic
                    gameState.combo++;
                    gameState.comboTimer = 120; // 2 seconds to chain
                    const scoreAdd = 50 * gameState.combo;
                    gameState.score += scoreAdd; gameState.levelScore += 50; 
                    
                    spawnFloatingText(`+${scoreAdd}`, b.x+b.width/2, b.y, '#fbbf24');
                    spawnParticles(b.x + b.width/2, b.y + b.height/2, b.baseColor, 15, 8); // Explosion
                    
                    if(gameState.energy < 100) gameState.energy = Math.min(100, gameState.energy + 2);
                    
                    updateHUD();
                    const rand = Math.random();
                    if (rand < 0.30) items.push(new Item(b.x+b.width/2, b.y+b.height/2, 'math'));
                    else if (rand < 0.40) items.push(new Item(b.x+b.width/2, b.y+b.height/2, Math.random() > 0.5 ? 'heal' : 'speed'));
                    else if (rand < 0.43) items.push(new Item(b.x+b.width/2, b.y+b.height/2, 'mega'));
                    else if (rand < 0.45) items.push(new Item(b.x+b.width/2, b.y+b.height/2, Math.random() > 0.5 ? 'shield' : 'freeze'));

                    gameState.camera.shake += 2;
                    AudioSys.sfxExplosion(); buildings.splice(i, 1);
                }
            }

            if (!boss && gameState.levelScore >= BOSS_SPAWN_THRESHOLD) triggerBoss();

            // Draw Order
            buildings.forEach(b => b.draw(ctx, cx, cy));
            items.forEach(i => { i.update(); i.draw(ctx, cx, cy); });
            particles.forEach((p, idx) => { p.update(); p.draw(ctx, cx, cy); if(p.life <= 0) particles.splice(idx, 1); });
            if (boss) boss.draw(ctx, cx, cy);
            
            projectiles.forEach(p => {
                ctx.shadowBlur = 10; ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                if(p.width) ctx.fillRect(p.x-cx, p.y-cy, p.width, 10); 
                else { ctx.beginPath(); ctx.arc(p.x-cx, p.y-cy, p.size || 5, 0, Math.PI*2); ctx.fill(); }
                ctx.shadowBlur = 0;
            });
            
            player.draw(ctx, cx, cy);
            
            floatingTexts.forEach((ft, i) => {
                ctx.save();
                ctx.fillStyle = ft.color; 
                ctx.font = `bold ${ft.size || 20}px 'Black Ops One'`; 
                ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                ctx.fillText(ft.text, ft.x-cx, ft.y-cy);
                ctx.restore();
                ft.y += ft.vy; ft.life--; if(ft.life <= 0) floatingTexts.splice(i, 1);
            });
            
            if (joystick.active) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(joystick.originX, joystick.originY, 50, 0, Math.PI * 2); ctx.stroke();
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(joystick.currentX, joystick.currentY, 20, 0, Math.PI * 2); ctx.fill();
            }
            if (gameState.health <= 0) endGame();
        }

        function endGame(victory = false) {
            gameState.status = STATE.GAME_OVER;
            document.getElementById('hud').classList.add('hidden'); document.getElementById('levelClearModal').classList.add('hidden');
            const modal = document.getElementById('gameOverModal'); modal.classList.remove('hidden');
            document.getElementById('endTitle').innerText = victory ? "MISSION COMPLETE" : "SYSTEM FAILURE";
            document.getElementById('endTitle').className = victory ? "text-4xl md:text-6xl text-yellow-400 tech-font mb-4 text-center" : "text-4xl md:text-6xl text-red-500 tech-font mb-4 text-center";
            document.getElementById('finalScore').innerText = Math.floor(gameState.score);
            document.getElementById('finalLevelInfo').innerText = `SECTOR REACHED: ${gameState.levelIndex + 1}`;
            loadLeaderboard();
        }

        // --- Local Storage Leaderboard ---
        const submitScoreBtn = document.getElementById('submitScoreBtn');
        
        submitScoreBtn.addEventListener('click', () => {
            const name = document.getElementById('playerNameInput').value.trim() || 'AGENT';
            const score = Math.floor(gameState.score);
            
            // Get existing scores
            let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || '[]');
            scores.push({ name, score, date: new Date().toISOString() });
            
            // Sort and keep top 20
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 20);
            
            localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
            
            document.getElementById('submitScoreSection').classList.add('hidden');
            loadLeaderboard();
        });

        function loadLeaderboard() {
            const list = document.getElementById('leaderboardList');
            const scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || '[]');
            
            list.innerHTML = '';
            if (scores.length === 0) {
                list.innerHTML = '<div class="text-center text-gray-600 py-4">NO LOCAL RECORDS</div>';
                return;
            }

            scores.forEach((s, i) => {
                const row = document.createElement('div'); 
                row.className = "flex justify-between py-2 border-b border-gray-800 text-sm";
                row.innerHTML = `<span class="text-gray-500 w-8">#${i+1}</span><span class="text-cyan-400 font-bold flex-1 text-left pl-2">${s.name}</span><span class="text-yellow-400 font-mono">${s.score}</span>`;
                list.appendChild(row);
            });
        }

        initGame();
    </script>
</body>
</html>
